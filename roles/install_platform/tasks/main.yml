---
#  vars:
#    volttron_source_changed: no

##NOTE there is no way to tell if the bootstrap steps are producing
##     changes or not, this is not idiomatic ansible. It would be
##     better if there were a changed condition.
##     >> could achieve this with a custom module that checks pip freeze
##        from before and after each call, maybe something simpler
- name: update pip in venv {{ volttron_venv }}
  pip:
    virtualenv: "{{ volttron_venv }}"
    virtualenv_command: "{{ python_interpreter }} -m venv"
    ## We add setuptools here because the module needs at
    ## a non-empty target list to avoid warnings and report
    ## change status correctly. The updates are separated because
    ## they fail when they are listed together. Probably an
    ## ordering thing.
    name:
    - pip>18.1
  environment:
    http_proxy: "{{ http_proxy }}"
    https_proxy: "{{ http_proxy }}"

- name: link the platform venv
  when: volttron_venv != (volttron_root + "/env")
  file:
    src: "{{ volttron_venv }}"
    dest: "{{ volttron_root }}/env"
    state: link

-name: install the VOLTTRON platform
  pip:
    virtualenv: "{{ volttron_venv }}"
    virtualenv_command: "{{ python_interpreter }} -m venv"
    name:
      - volttron # TODO: add version
  environment:
    http_proxy: "{{ http_proxy }}"
    https_proxy: "{{ http_proxy }}"

# NOTE: I don't think this is necessary anymore.
# - name: Install extra requirements for this instance
#   pip:
#     virtualenv: "{{ volttron_venv }}"
#     name: "{{ extra_requirements }}"
#   environment:
#     HTTP_PROXY: "{{ http_proxy }}"
#   when: (extra_requirements | length) > 0

- name: create environment activation script
  template:
    src: activate-instance-env.j2
    dest: "{{ ansible_env.HOME }}/activate-{{ instance_name }}-env"

# configure the platform
- name: ensure VOLTTRON_HOME exists
  file:
    path: "{{ volttron_home }}"
    state: directory
    mode: 0755
- name: set instance name
  ini_file:
    path: "{{ volttron_home }}/config"
    section: volttron
    option: instance-name
    value: "{{ instance_name }}"
    mode: '0600'
    backup: yes
- name: set message bus
  ini_file:
    path: "{{ volttron_home }}/config"
    section: volttron
    option: message-bus
    value: "{{ message_bus }}"
    mode: '0600'
    backup: yes
- name: ensure platform configuration
  loop: "{{ host_configuration.config | dict2items }}"
  ini_file:
    path: "{{ volttron_home }}/config"
    section: volttron
    option: "{{ item.key }}"
    value: "{{ item.value }}"
    mode: '0600'
    backup: yes

# For RMQ, do the extra config/bootstrapping/cert generation
- name: rabbitmq configuration
  when: message_bus == "rmq"
  block:
  - name: create rabbitmq config
    template:
      src: rabbitmq_config.yml.j2
      dest: "{{ volttron_home }}/rabbitmq_config.yml"

  - name: run vcfg to configure for RMQ
    ##NOTE: note that this task will always report changes and will replace and recreate the rmq confg (even if no changes)
    ##      this is not great design generally, and violates idempotent expectations in ansible. For now we roll with it.
    expect:
      command: "{{ volttron_venv }}/bin/vcfg --vhome {{ volttron_home }} --instance-name {{ instance_name }} --rabbitmq single {{ volttron_home }}/rabbitmq_config.yml"
      responses:
        '.*Remove [a-zA-Z1-9_\-./]*/rabbitmq.conf?.*': 'y'
        '.*Do you want to use this certificate.*': ''
      timeout: 90
    register: vcfg_result
    ignore_errors: "{{verbose_debug_tasks | bool}}"
  - fail:
      msg: "vcfg failed because the instance is running, you must stop it (perhaps with the volttron.deployment.run_platform role)"
    when: '"The current instance is running" in vcfg_result.stdout'
  - name: debug print of vcfg results
    when: verbose_debug_tasks | bool
    debug:
      msg: "{{ vcfg_result }}"
    failed_when: vcfg_result.failed

